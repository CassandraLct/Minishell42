Reste à faire:
	*signaux: faire ctrl-D, ctrl-c, ctrl-\;
	*les chevrons, pipe, $?;
	*lexer: gerer les cotes;
	*exit $quelque chose , exit normalement, (gerer avec le $)?

/!\ Objectif 8/12 (vendredi):
	-> Finir unset (enlever une variable d'export) : Fait et seg fault regler!
	-> Finir export (changer valeur d'une variable (env, export)) : Fait!
	-> Finir echo (cas -n expres un 1er arg) : Fait!
	-> Faire un coup de norminette : Fait!
	-> Verifier les leaks (leaks ne fonctionne pas avec fsanitize) : 1 leak
	*Si le temps commencer les signaux : Fait
		signaux: https://www-apr.lip6.fr/~chaillou/Public/enseignement/MA1/TD3/node1.html (debut interessant)
				 http://pauillac.inria.fr/~remy/poly/system/camlunix/sign.html (explication du fonctionnement)
				 https://btholt.github.io/complete-intro-to-linux-and-the-cli/signals-and-the-power-of-ctrl
		sigint	Interruption (ctrl-C)
		sigquit	Interruption forte (ctrl-\)
		sigquit	Interruption forte (ctrl-D)
	/*utiliser unlink pour heredoc ?*/

/!\ Objectif 13/12 (Mardi):
	-> Comprendre les signaux; debut
	-> Tester le fonctionnement d'Export et Unset; Fait
	-> Continuer cd et faire le changement de directory;
	-> voir pour l'execve(fork)(surement utile pour les signaux);
	-> chercher de la doc pour Makefile

/!\ Objectif 15/12 (Jeudi):
	->Finir cd: modification des valeurs de pwd et oldpwd;
		-> dernier cas a gerer: si un path est donner
	->Norminette a faire: cd: 2fonctions +25lignes,

/!\ Objectif 19/12 (Lundi):
	-> Finir cd (cd, cd /, cd path absolu) : Fait
	-> Avancer les signaux: impossibilité d'utiliser la fonction rl_replace_line()
	-> Faire la norminette: Fait (reste les WRONG_SCOPE_COMMENT)
	/!\ free le path pour cd: Fait

/!\ Objectif 20/12 :
	-> cd verifier quand cd /, puis cd Users/...; enlever le / : Fait
	-> signaux: reussir a utiliser rl_replace_line(): Fait
	->Continuer les signaux (sans la gestion des pipes, sans le fork) 
	//faire une fois les pipes et les fork fait

/!\ Objectif 26/12 :
	-> Fixer la gestion de la structure: Fait
	-> Corriger les leaks :
		export : leaks lors de l'ajout d'une variable dans export(tableau?)
		unset : 0 leaks pour le moment;
	-> Faire le fork execve; Fait (a tester pour tous les cas)
		*pb : fait 2 fois exit (parfois)

/!\ Objectif 27/12 :
	-> Faire les chevrons(utiliser dup), heredoc;
	-> Faire les pipes ();
	-> gerer les cotes(niveau du split); fait 
	-> gerer le $?, gestion du $;
	-> finir les signaux(voir la fonction signal); fait
	-> verifier les leaks;
	-> voir pour changer l'environnement (OLDPWD absent au debut);

/!\ Pour lundi mettre en commun les idees de gestion des pipes (cmd multiple)

/!\ Fait aujourd'hui 09/01 (cassandra):
	-> norminette
	-> debut essai gestion des cotes :
		*reussir a copier et split correctement sur les espaces et des qu'il y a des cotes
		copier le contenu (sans split sur les espaces) et supprimer celle-ci lors de la copie
		ex : 'echo' devient echo ; "Hello World" devient Hello World

/!\ Mardi 10/01:
	-> recoder strcmp; fait
	-> voir la gestion des pipes; (schéma)

/!\ Mercredi 11/01:
	-> finir les signaux;
		->ctrl c fait; ctrl \ fait; ctrl d segfault quand line vide

/!\ Jeudi 12/01:
	-> finir ctrl-d quand il doit exit
		-> ne passe pas dans les fonctions signaux 
		-> ctrl-d est un EOF ? utiliser tgets ?
	-> Signaux fini! (a tester si fonctionne correctement avec heredoc)

Raph :
	-> gestion des cotes;
	-> decoupage de la ligne par groupe puis par commande;

si le $VAR est ente cotes ou double affiche la valeur de la var
sinon affiche juste le nom
pour le message d'erreur si dans le term ecrit ex: $COLORTERM
-> bash: truecolor: command not found (for for "$COLORTERM")
et '$COLORTERM' -> bash: $COLORTERM: command not found

si pipe sans rien affiche une erreur
si cmd pipe et rien le prog demande une deuxieme cmd
ex :
	bash-3.2$ cat test |
	> echo bonjour
	bonjour

heredoc :
bash-3.2$ cat << end
> $PWD
> END
> end
/Users/clecat/Desktop/Cursus/Minishell42
END
bash-3.2$ cat
$PWD
$PWD
"$PWD"
"$PWD"
^C
bash-3.2$

/!\ a regler lundi : cd ~/Desktop ne va pas au dossier; Fait

/!\Lundi 16/01:
	-> finir cd ~; fait
	-> faire fonction $; commencer seg fault pour la suite du parcours
	-> fixe exit : minishell> $PWD
				   minishell: $PWD: command not found
				   minishell> exit
				   exit
				   minishell> exit
				   exit

/!\ Mardi 17/01:
	-> finir fonction $ : fait

pour demain:
	-> faire le $?; condition faite FAITE
	(faire fonction cette aprem et verifier qu'il y est les ret_err partout)
	-> mettre a la norme; commencer
	-> fix echo -n -n qui fait un -n basique FAIT
	-> commencer a verifier les leaks (fait pour le $)

/!\ Mercredi 18/01:
	-> fix segfault de gestion $; Fait
	-> $?; fait
	-> debut norme; FAIT (sauf exec.c 2 fonctions + 25 lignes)
	-> pas de leaks pour fonctions gestion dollar
	-> verifier tout les ret_erreur; en cours
	-> echo -n -n (-nnnnn -nnnnn aussi); Fait
	-> a gerer : si unset PATH : Fait
			bash-3.2$ unset PATH
			bash-3.2$ ls
			bash: ls: No such file or directory
			bash-3.2$ $?
			bash: 127: No such file or directory
			bash-3.2$ env
			bash: env: No such file or directory

/!\demain : regler le soucis d'exit (du aux forks)
*unset PWD : unset pwd mais la cmd pwd fonctionne | Fait
	a gerer comme le bash ou faire gestion d'erreur

/!\ Jeudi 19/01:
	-> gerer le unset pwd; Fait
	-> norme (parse splitline pas fait car sera changer); Fait
	-> regler le soucis du exit avec les forks (voir avec Thomas); Fait
	-> reverifier les retour erreur $?; Fait
	-> leaks ; en cours

ret_erreur : *export;Fait
			*exit; Fait
			*pwd; Fait
			*echo; Pas de ret_err
			*unset; Fait
			*signaux; Fait
			*cd; Fait (niveau de chdir)
			*chevrons; Fait

leaks : *echo : 0 leaks
		*cmd execve ne leaks plus;
		*export: 0 leaks
		*cd : ~(2 leaks) regler; ~/Desktop(2 leaks) regler; built-in 0 leak; cd ./Buil-in 0 leaks; cd ../Libft42 0 leaks
			././.././Libft42/ 0 leaks
		$: $PWD fait 3 leaks (surement )

-> si line est juste $PWD doit renvoyer bash: /Users/clecat/Desktop/Cursus: is a directory

/!\ demain: finir les leaks, faire fonction de verif directory

/!\ Vendredi 20/01:
	->soucis de segfault su cd$bonjour$$$HOME regler;

/!\ Samedi 21/01:
	-> regler le soucis de la fonction $;
	-> changer les dernier built-in avec la structure cmd; Fait
	-> faire la norme; commencer
	-> faire fonction de verification dossier; (pour redirection et $PWD)
	-> organiser le .h; Fait
	-> faire fonction free de struct_cmd; Fait
		* cd Desktop/Cursus/ segfault (segfault regler)

norme : *export_change_val.c : 2 fonctions +25lignes
		*gestion_dollar.c : 1 fonction +25lignes

lundi : 
	*finir le $;
	*faire la norme;
	*verifier les leaks;

a commencer lundi :
	*gerer les multi_pipes;
	*faire les redirections;

Lundi 23/01 :
	-> finir la gestion du $; fait
	-> faire la norme;
	-> verifier les leaks; Fait
	-> commencer les pipes;
	-> commencer les redirections;

verifier pourquoi le minishell ne se supprime pas au moment du make fclean

pour demain :
	-> gerer le $cotes;
	-> faire la norme;
	-> faire la suppression des cotes;
	-> revoir la gestion des cotes lors du split (seg fault);

Mardi 24/01 :
	-> faire gestion quotes dollar ; Fait 
	-> verifier les leaks ; Fait
	-> Faire la norme ;

apres la fonction de decoupage, parcourir les tableau de commande pour supprimer les quotes exterieur

Mercredi 25/01 :
	-> Faire la norme; Fait
	-> Faire fonction supression cotes exterieur; Fait
	-> Verifier les leaks; Fait
	-> Regler le pb des cotes au niveau du spliteur; fixe

demain : 
	-> comprendre la gestion des pipes(code Raph);
	-> tester tous les cas;

Jeudi 26/01 :
	-> heredoc : fait

*comprendre pk "ec"ho(ou autre commande) fonctionne

demain : 
	-> voir les cas de cmd avec cotes en plein milieu; 
		-> idée si en enlevant les cotes la commande existe enlever les cotes sinon return;
reate a faire :
-> finir les pipes;
-> finir les redirections;
-> voir fonction cmd avec redirection;
-> faire fonction de gestion cmd existante avec cotes au milieu;

Vendredi 27/01 :
	-> faire fonctions de suppression cotes en plein milieu d'une commande; Fait
	-> recuperer ce qu'il y a avant et apres; Fait

a faire demain :
	-> penser a strjoin la line modifier avec le debut et la fin;
	-> tester les cas étranges;
	-> verifier les leaks;
	-> faire la norme;

Samedi 28/01 :
	-> faire un join si un debut et une fin de line; Fait
	-> faire gestion du cas $; en cours 
	-> faire gestion du cas chevrons; fait
	-> modifier les fonctions des dollars; en cours (compter le nombre de cote)
	-> si une chevron seul mettre erreur : bash: syntax error near unexpected token `newline';

*pour le cas : minishell> echo "toto 'est' beau" : erreur de malloc (pointeur free est non alloué);

Mercredi 01/02:
	-> Finir la gestion des cotes; Fait
	-> Faire la norme; Fait
	-> Verifier les leaks; Fait pour le debut du prog (jusqu'au if du main)
	-> Mise en commun des codes; sur branch git : merged 2

Jeudi 02/02:
	-> Faire les test;
	-> Verifier les leaks;

LEAKS : 
	->leaks creer lors de l'affectation du resultat de spliter3 dams struct_cmd (main);
	->4 root leaks creer lorsapres la fonction redir_pipe;
	-> regler le soucis de signaux dans le heredoc qui quitte bien le heredoc, affiche le prompt minishell 
		puis relance un heredoc;
	-> seg fault lorsque que le heredoc est fait directement sans cmd;
	