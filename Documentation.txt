reproduire un shell

se documenter sur :
	-fichier a rendre
	-fonction autorisee!
	-commande a recreer
	-comportement du bash

____FICHIER A RENDRE______

*nom programme : minishell
*doit contenire: Makefile, .h et .c
*possibiliter d'utiliser notre libft

______FONCTION AUTORISEE_____

prompt : invite de commande;

printf,malloc,free,write,access,open,read,close,
*readline :
	#include <stdio.h>
	#include <readline/readline.h>
	#include <readline/history.h>

	char *
	readline (const char *prompt);
	readline va lire une ligne a partir du terminal et la retourner, en utilisant le const char *prompt en prompt.
	si le prompt est NULL ou la chaine vide, aucun prompt n'est emise. La ligne retourner est definie par malloc,
	il faudra la free une fois fini.
*rl_clear_history:
*rl_on_new_line: int rl_on_new_line ()
Tell the update routines that we have moved onto a new (empty) line, usually after ouputting a newline.
*rl_replace_line:
*rl_redisplay: Change what's displayed on the screen to reflect the current contents of rl_line_buffer.
*add_history: void add_history (const char *string)
Place string at the end of the history list. The associated data field (if any) is set to NULL.
*fork:
*wait:
*waitpid:
*wait3:
*wait4:
*signal:
*sigaction: Examiner et modifier l'action associée à un signal
#include <signal.h>
int sigaction(int signum, const struct sigaction *act,  struct sigaction *oldact);
http://manpagesfr.free.fr/man/man2/sigaction.2.html
*sigemptyset:#include <signal.h>
int sigemptyset(sigset_t *set);
initializes the signal set given by set to empty, with all signals excluded from the set.
*sigaddset: #include <signal.h>
int sigaddset(sigset_t *set, int signum);
add signal signum from set;
*kill: Envoyer un signal à un processus
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
*exit:
*getcwd: Obtenir le répertoire de travail courant 
	#include <unistd.h>
	char *getcwd(char *buf, size_t size);
*chdir:#include <unistd.h>
int chdir(const char *path);
remplace le répertoire de travail courant du processus appelant par celui indiqué dans le chemin path.
*stat:#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int stat(const char *path, struct stat *buf);
stat() récupère l'état du fichier pointé par path et remplit le tampon buf.
*lstat:#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int lstat(const char *path, struct stat *buf);
lstat() est identique à stat(), sauf que si path est un lien symbolique, il donne l'état du lien lui-même plutôt que celui du fichier visé.
*fstat: #include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int fstat(int fd, struct stat *buf);
est identique à stat(), sauf que le fichier ouvert est pointé par le descripteur fd, obtenu avec open(2).
*unlink: #include <unistd.h>
int unlink(const char *pathname);  
Détruire un nom et éventuellement le fichier associé 
unlink() détruit un nom dans le système de fichiers. Si ce nom était le dernier lien sur un fichier, et si aucun processus n'a ouvert ce fichier, ce dernier est effacé, et l'espace qu'il utilisait est rendu disponible.
Si le nom était le dernier lien sur un fichier, mais qu'un processus conserve encore le fichier ouvert, celui-ci continue d'exister jusqu'à ce que le dernier descripteur le référençant soit fermé.
Si le nom correspond à un lien symbolique, le lien est supprimé.
Si le nom correspond à une socket, une FIFO, ou un périphérique, le nom est supprimé mais les processus qui ont ouvert l'objet peuvent continuer à l'utiliser. 
*execve:#include <unistd.h>
int execve(const char *fichier, char *const argv[], char *const envp[]);  
*dup:
*dup2:
*pipe: #include <unistd.h>
int pipe(int pipefd[2]);
Cet appel renvoie 0 s'il réussit, ou -1 s'il échoue, auquel cas errno contient le code d'erreur.
*opendir: ouvrir un repertoire
#include <sys/types.h>
#include <dirent.h>
DIR *opendir(const char *name);
La fonction opendir() ouvre un flux répertoire correspondant au répertoire name, et renvoie un pointeur sur ce flux. Le flux est positionné sur la première entrée du répertoire.
*readdir: #include <dirent.h>
struct dirent *readdir(DIR *dir);
int readdir(DIR *dir, struct dirent *entry, struct dirent **result);
La fonction readdir() renvoie un pointeur sur une structure dirent représentant l'entrée suivante du flux répertoire pointé par dir. Elle renvoie NULL à la fin du répertoire, ou en cas d'erreur.
*closedir: #include <sys/types.h>
#include <dirent.h>
int closedir(DIR *dir);
La fonction closedir() ferme le flux de répertoire associé à dir. Après cette invocation, le descripteur dir du flux de répertoire n'est plus disponible.
*strerror:
*perror:
*isatty: #include <unistd.h>
Vérifier si un descripteur se rapporte à un terminal
int isatty(int desc);
renvoie 1 si desc est un descripteur de fichier ouvert connecté à un terminal, ou 0 autrement.  
*ttyname:#include <unistd.h>
char *ttyname(int fd);
obtenir le nom d'un terminal
*ttyslot:
*ioctl:
*getenv:
*tcsetattr:
*tcgetattr:
*tgetent:
*tgetflag:
*tgetnum:
*tgetstr:
*tgoto:
*tputs:

_______COMMANDES A RECREER________

-recreer un prompt
-avoir un historique fonctionnel
-chercher et lancer le bon executable (en se basant sur la variable path ou un chemin relatif/absolu)
-1 variable globale autorisee
-ne pas interpreter de quotes non fermés, ou de caractere speciaux non demandes : le \, le ;
-gerer les single quotes qui doit empecher le shell d'interpreter les meta-caracteres present entre guillemets
-gerer les double quotes qui doit empecher le shell d'interpreter les meta-caracteres presents entre guillemets sauf le $
-implementer les redirections : 
	- < doit rediriger l'entree;
	- > doit rediriger la sortie;
	- << doit recevoir un delimiteur et lire l'input donné jusqu'à rencontrer une ligne contenant le delimiteur.L'historique ne doit pas etre mis a jour
	- >> doit rediriger la sortie en mode append (?)
- Implementer les pipes (|): la sortie de chaque pipeline est connecter a l'entree de la commande suivante grace a un pipe
-gerer les variables d'environnement(un $ suivi d'une sequence de caracteres) qui doivent etre substitues par leur contenu.
-gerer $? qui doit etre substitue par le statut de sortie de la derniere pipeline executee au premier plan
-gerer ctrl-C, ctrl-D et ctrl-\ et fonctionner comme dans bash
-en mode interactif:
	-ctrl-C affiche un nouveau prompt sur une nouvelle ligne
	-ctrl-D quitte le shell
	-ctrl-\ ne fait rien
-le shell doit implementer les builtins suivantes :
	-echo et l'option -n;
	-cd uniquement avec un chemin relatif ou absolu;
	-pwd sans aucune option
	-export sans aucune option
	-unset sans aucune option
	-env sans aucune option ni argument
	-exit sans aucune option
/!\ la fonction readline() peut causer des fuites memoires a ne pas gerer mais notre code ne doit
pas avoir fuites memoires

/!\ Getting started
There is a github repository that obeys the order of proceedings pretty nicely: https://github.com/Swoorup/mysh
Please make sure to do a lexer -> parser -> expander -> executor to make your life easier. Here is a solid start.
Make sure that you understand the shell syntax /!\

_______COMPORTEMENT DU SHELL_______

