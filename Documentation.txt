reproduire un shell

se documenter sur :
	-fichier a rendre
	-fonction autorisee!
	-commande a recreer
	-comportement du bash

____FICHIER A RENDRE______

*nom programme : minishell
*doit contenire: Makefile, .h et .c
*possibiliter d'utiliser notre libft

______FONCTION AUTORISEE_____

prompt : invite de commande;

printf,malloc,free,write,access,open,read,close,
*readline :
	#include <stdio.h>
	#include <readline/readline.h>
	#include <readline/history.h>

	char *
	readline (const char *prompt);
	readline va lire une ligne a partir du terminal et la retourner, en utilisant le const char *prompt en prompt.
	si le prompt est NULL ou la chaine vide, aucun prompt n'est emise. La ligne retourner est definie par malloc,
	il faudra la free une fois fini.
*rl_clear_history:
*rl_on_new_line: int rl_on_new_line ()
Tell the update routines that we have moved onto a new (empty) line, usually after ouputting a newline.
*rl_replace_line:
*rl_redisplay: Change what's displayed on the screen to reflect the current contents of rl_line_buffer.
*add_history: void add_history (const char *string)
Place string at the end of the history list. The associated data field (if any) is set to NULL.
*fork:
*wait:
*waitpid:
*wait3:
*wait4:
*signal:
*sigaction: Examiner et modifier l'action associée à un signal
#include <signal.h>
int sigaction(int signum, const struct sigaction *act,  struct sigaction *oldact);
http://manpagesfr.free.fr/man/man2/sigaction.2.html
*sigemptyset:#include <signal.h>
int sigemptyset(sigset_t *set);
initializes the signal set given by set to empty, with all signals excluded from the set.
*sigaddset: #include <signal.h>
int sigaddset(sigset_t *set, int signum);
add signal signum from set;
*kill: Envoyer un signal à un processus
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
*exit:
*getcwd: Obtenir le répertoire de travail courant 
	#include <unistd.h>
	char *getcwd(char *buf, size_t size);
*chdir:#include <unistd.h>
int chdir(const char *path);
remplace le répertoire de travail courant du processus appelant par celui indiqué dans le chemin path.
*stat:#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int stat(const char *path, struct stat *buf);
stat() récupère l'état du fichier pointé par path et remplit le tampon buf.
*lstat:#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int lstat(const char *path, struct stat *buf);
lstat() est identique à stat(), sauf que si path est un lien symbolique, il donne l'état du lien lui-même plutôt que celui du fichier visé.
*fstat: #include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int fstat(int fd, struct stat *buf);
est identique à stat(), sauf que le fichier ouvert est pointé par le descripteur fd, obtenu avec open(2).
*unlink: #include <unistd.h>
int unlink(const char *pathname);  
Détruire un nom et éventuellement le fichier associé 
unlink() détruit un nom dans le système de fichiers. Si ce nom était le dernier lien sur un fichier, et si aucun processus n'a ouvert ce fichier, ce dernier est effacé, et l'espace qu'il utilisait est rendu disponible.
Si le nom était le dernier lien sur un fichier, mais qu'un processus conserve encore le fichier ouvert, celui-ci continue d'exister jusqu'à ce que le dernier descripteur le référençant soit fermé.
Si le nom correspond à un lien symbolique, le lien est supprimé.
Si le nom correspond à une socket, une FIFO, ou un périphérique, le nom est supprimé mais les processus qui ont ouvert l'objet peuvent continuer à l'utiliser. 
*execve:#include <unistd.h>
int execve(const char *fichier, char *const argv[], char *const envp[]);  
*dup:
*dup2:
*pipe: #include <unistd.h>
int pipe(int pipefd[2]);
Cet appel renvoie 0 s'il réussit, ou -1 s'il échoue, auquel cas errno contient le code d'erreur.
*opendir: ouvrir un repertoire
#include <sys/types.h>
#include <dirent.h>
DIR *opendir(const char *name);
La fonction opendir() ouvre un flux répertoire correspondant au répertoire name, et renvoie un pointeur sur ce flux. Le flux est positionné sur la première entrée du répertoire.
*readdir: #include <dirent.h>
struct dirent *readdir(DIR *dir);
int readdir(DIR *dir, struct dirent *entry, struct dirent **result);
La fonction readdir() renvoie un pointeur sur une structure dirent représentant l'entrée suivante du flux répertoire pointé par dir. Elle renvoie NULL à la fin du répertoire, ou en cas d'erreur.
*closedir: #include <sys/types.h>
#include <dirent.h>
int closedir(DIR *dir);
La fonction closedir() ferme le flux de répertoire associé à dir. Après cette invocation, le descripteur dir du flux de répertoire n'est plus disponible.
*strerror:
*perror:
*isatty: #include <unistd.h>
Vérifier si un descripteur se rapporte à un terminal
int isatty(int desc);
renvoie 1 si desc est un descripteur de fichier ouvert connecté à un terminal, ou 0 autrement.  
*ttyname:#include <unistd.h>
char *ttyname(int fd);
obtenir le nom d'un terminal
*ttyslot:
*ioctl:
*getenv:
*tcsetattr:
*tcgetattr:
*tgetent:
*tgetflag:
*tgetnum:
*tgetstr:
*tgoto:
*tputs:

_______COMMANDES A RECREER________



_______COMPORTEMENT DU SHELL_______